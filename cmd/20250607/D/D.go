package main

import (
	"bufio"
	"fmt"
	"os"
)

/*
1. 贪心：想让最靠前的位置最小

字典序最小，就是希望 字符串的前缀尽可能小，所以我们要考虑哪些操作能使得：

	S 的前缀更小。

	在原始字符串中，找到第一个不升的位置 i，即 S[i] > S[i+1]。

	    这说明当前字符串存在“下降”，意味着前缀可以通过某种方式变得更小

	    比如 "abcde" 是严格升序，就不能改得更小

	    但 "abzcd" 中的 z > c 就可能通过移动 z 来得到更优前缀

这正是你那段代码中：

for i in range(N - 1):

	if S[i] > S[i + 1]:
	    l = i
	    break

的意义 —— 找到第一个下降点 l。

------------------------------------

2. 为什么选 r 为第一个 S[j] > S[l] 就停止？

这一段是：

r = N
for j in range(l + 1, N):

	if S[l] < S[j]:
	    r = j
	    break

原因在于：

	如果你让区段 [l, r] 太长，会把更小的字符（如 S[l+1], S[l+2]）推前，可能反而不如只旋转一小段更优。

	所以，一旦遇到某个字符 大于 S[l]，再把 S[l] 插进去就不会更优了。

	因此，我们选最短的合法区段来左旋，使得变动越小越好（保留更多前缀）

主要是这句，所以其实只用找到第一个降序的字符就行了，反而不用想太复杂。。。（还是对，字典顺序不理解啊）

	辞書順で小さくできる場合，できるだけ先頭に近い文字の辞書順を小さくしたほうが文字列全体の辞書順も小さくなるため

------------------

	本解説では，操作後の文字列を S′ と表記して，もとの

S と区別します．

ℓ=r として操作をすれば S′=S とできるため，答えが S よりも辞書順で後に現れることはないです．以降，

ℓ+1≤r の場合を考えます．

まず，最適な
ℓ を決めます．Sℓ​>Sℓ+1​ ならば，操作によって S よりも辞書順で小さい文字列を得ることができます．逆に，すべての 1≤i≤N−1 で Si​≤Si+1​ ならば，どのように操作を行っても S より辞書順で小さい文字列を作ることができません．辞書順で小さくできる場合，できるだけ先頭に近い文字の辞書順を小さくしたほうが文字列全体の辞書順も小さくなるため，ℓ としては Si​>Si+1​ が成り立つ 1≤i≤N−1 のうちもっとも小さいものを選ぶのが最適です．そのような i が存在しなければ，ℓ=r として操作をするのが最適で，答えは

S です．

次に，最適な
r を決めます．Sℓ​ 以下の文字が S の ℓ+1 文字目以降に続く限り，Sℓ​ を後ろに追いやるほうが辞書順で良いので，r は，Sℓ​<Sj+1​ が成り立つ ℓ+1≤j≤N−1 のうち最小のものが最適です．そのような j が存在しなければ，r=N が最適です．
*/
func main() {
	br := bufio.NewReader(os.Stdin)

	var T int
	fmt.Fscanln(br, &T)

	for i := 0; i < T; i++ {
		var N int
		fmt.Fscanln(br, &N)

		var S string
		fmt.Fscanln(br, &S)

		solve(S)
	}
}

func solve(S string) {
	N := len(S)

	l := -1
	for i := 0; i < N-1; i++ {
		if S[i] > S[i+1] {
			l = i
			break
		}
	}

	if l == -1 {
		fmt.Println(S)
		return
	}

	r := N
	for j := l + 1; j < N; j++ {
		if S[l] < S[j] {
			r = j
			break
		}
	}

	// 构造 S[:l] + S[l+1:r] + S[l] + S[r:]
	result := S[:l] + S[l+1:r] + string(S[l]) + S[r:]
	fmt.Println(result)
}
