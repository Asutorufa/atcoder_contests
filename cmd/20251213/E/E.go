package main

import (
	"bufio"
	"fmt"
	"os"
)

// 群论都来了，没读过研究生还真不行
func main() {
	in := bufio.NewReader(os.Stdin)

	var N int
	fmt.Fscan(in, &N)

	P := make([]int, N)
	for i := 0; i < N; i++ {
		fmt.Fscan(in, &P[i])
		P[i]-- // 0-indexed にする
	}

	visited := make([]bool, N)
	var ans int64 = 0

	for i := 0; i < N; i++ {
		if visited[i] {
			continue
		}

		// サイクルを辿る
		cnt := 0
		cur := i
		for !visited[cur] {
			visited[cur] = true
			cur = P[cur]
			cnt++
		}

		if cnt >= 2 {
			ans += int64(cnt * (cnt - 1) / 2)
		}
	}

	fmt.Println(ans)
}

/*
这段 Go 语言代码实现的是一个基于**置换群论（Permutation Group Theory）**概念的算法。它主要用于计算一个给定置换（即数组 P）中所有**循环（Cycles）**内部可以形成多少个**元素对（Pairs）**。

###核心概念与算法（Algorithms and Core Concepts）---

####1. 什么是置换（Permutation）？数组 P 表示一个置换。如果 P 的长度是 N，则它描述了 N 个元素 \{0, 1, \dots, N-1\} 的一个重新排列（或映射）。

* P[i] = j 意味着元素 i 被映射到了位置 j。
* **代码中的处理：** 输入的值通常是 1-based (从 1 开始)，但代码通过 `P[i]--` 将其转换为 **0-based (从 0 开始)** 索引，这更符合计算机数组的处理习惯。



####2. 什么是循环分解（Cycle Decomposition）？当你根据置换 P 的规则不断追踪元素的去向时，元素最终会回到起点，形成一个闭合的路径，这被称为一个**循环 (Cycle)**。

* 例如，如果 0 \to 1，1 \to 2，2 \to 0，那么 (0, 1, 2) 就构成了一个长度为 3 的循环。
* 任何置换都可以分解成互不相交的循环的乘积。

####3. 算法步骤（How the Code Works）1. **初始化：**
* `visited` 数组用来标记哪些元素已经被分配到某个循环中，防止重复计算。
* `ans` 用来存储最终的成对数总和。


2. **遍历与查找循环：**
* 代码从 i=0 开始遍历所有元素。
* 如果元素 i 尚未被访问 (`!visited[i]`)，说明它是一个新循环的起点。


3. **追踪循环（Cycle Traversal）：**
* 从 `cur = i` 开始，进入一个内部循环。
* 在这个循环中，代码沿着置换关系 `cur = P[cur]` 不断前进。
* 每前进一次，就将当前元素标记为已访问 (`visited[cur] = true`)，并增加循环的长度计数器 `cnt`。
* 这个过程一直持续，直到它回到了循环的起点（或者说，直到它遇到一个已被标记为访问过的元素，而这个元素正是当前循环的一部分）。


4. **计算贡献值：**
* 当一个长度为 cnt 的完整循环被发现后，代码会计算这个循环内部可以形成多少个**无序对**。
* 这个值是组合数 C(cnt, 2)，即从 cnt 个元素中选取 2 个元素的方法数。
*
* 这个值被累加到 `ans` 中。



####4. 算法目的（The Goal）最终的 `ans` 代表了在所有元素中，有多少对不同的元素 \{i, j\} 位于**同一个**置换循环中。

###为什么计算 C(cnt, 2)？在置换群的上下文中，如果两个元素 i 和 j 属于同一个循环，这意味着可以通过对置换 P 应用足够多次，使得 i 能够映射到 j，反之亦然。这种“可相互转换”的关系是这个算法要计算的**等价关系对**。

###总结* **使用的算法：** **图遍历（Graph Traversal）**或**置换的循环分解（Cycle Decomposition of Permutations）**。
* **数据结构：** 使用了布尔数组 `visited` 来辅助记录状态，这类似于图算法中的标记数组。
* **用途：** 统计置换分解后，所有循环中元素对的总数。

如果您想更直观地理解，我可以提供一个具体的例子来说明数组是如何分解成循环并计算出结果的。您想看这个例子吗？
*/
